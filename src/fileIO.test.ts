import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import {
  readIniFile,
  readJsonFile,
  writeJsonFile,
  fileExists,
  isDirectory,
  isFile,
  isWritable,
  getBasename,
  getDirname,
  joinPath,
  isConfigBundle,
  processConfigBundle,
  getChildren
} from './fileIO';

describe('fileIO', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'test-'));
  });

  afterEach(() => {
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  describe('readIniFile', () => {
    it('should read and parse INI file', () => {
      const iniPath = path.join(tempDir, 'test.ini');
      const content = `# generated by PrusaSlicer
layer_height = 0.2
extrusion_width = 0.4
perimeter_speed = 60
`;
      fs.writeFileSync(iniPath, content);

      const { config, slicerFlavor } = readIniFile(iniPath);
      expect(config['layer_height']).toBe('0.2');
      expect(config['extrusion_width']).toBe('0.4');
      expect(config['perimeter_speed']).toBe('60');
      expect(slicerFlavor).toBe('PrusaSlicer');
    });

    it('should detect SuperSlicer flavor', () => {
      const iniPath = path.join(tempDir, 'test.ini');
      const content = `# generated by SuperSlicer
layer_height = 0.2
`;
      fs.writeFileSync(iniPath, content);

      const { slicerFlavor } = readIniFile(iniPath);
      expect(slicerFlavor).toBe('SuperSlicer');
    });

    it('should skip comments and empty lines', () => {
      const iniPath = path.join(tempDir, 'test.ini');
      const content = `# This is a comment
# Another comment

layer_height = 0.2
# Inline comment
extrusion_width = 0.4
`;
      fs.writeFileSync(iniPath, content);

      const { config } = readIniFile(iniPath);
      expect(config['layer_height']).toBe('0.2');
      expect(config['extrusion_width']).toBe('0.4');
      expect(config['# This is a comment']).toBeUndefined();
    });

    it('should trim whitespace from keys and values', () => {
      const iniPath = path.join(tempDir, 'test.ini');
      const content = `  layer_height  =  0.2  
  extrusion_width  =  0.4  `;
      fs.writeFileSync(iniPath, content);

      const { config } = readIniFile(iniPath);
      expect(config['layer_height']).toBe('0.2');
      expect(config['extrusion_width']).toBe('0.4');
    });

    it('should throw error for non-existent file', () => {
      expect(() => readIniFile(path.join(tempDir, 'nonexistent.ini'))).toThrow();
    });
  });

  describe('readJsonFile', () => {
    it('should read and parse JSON file', () => {
      const jsonPath = path.join(tempDir, 'test.json');
      const data = { version: '1.6.0.0', name: 'test' };
      fs.writeFileSync(jsonPath, JSON.stringify(data));

      const result = readJsonFile(jsonPath);
      expect(result.version).toBe('1.6.0.0');
      expect(result.name).toBe('test');
    });

    it('should throw error for invalid JSON', () => {
      const jsonPath = path.join(tempDir, 'invalid.json');
      fs.writeFileSync(jsonPath, '{ invalid json }');

      expect(() => readJsonFile(jsonPath)).toThrow();
    });

    it('should throw error for non-existent file', () => {
      expect(() => readJsonFile(path.join(tempDir, 'nonexistent.json'))).toThrow();
    });
  });

  describe('writeJsonFile', () => {
    it('should write JSON file with pretty formatting', () => {
      const jsonPath = path.join(tempDir, 'output', 'test.json');
      const data = { version: '1.6.0.0', name: 'test' };

      writeJsonFile(jsonPath, data);

      expect(fs.existsSync(jsonPath)).toBe(true);
      const content = fs.readFileSync(jsonPath, 'utf-8');
      expect(content).toContain('"version": "1.6.0.0"');
      expect(content).toContain('"name": "test"');
      expect(content.endsWith('\n')).toBe(true);
    });

    it('should create parent directories if they do not exist', () => {
      const jsonPath = path.join(tempDir, 'nested', 'deep', 'test.json');
      const data = { test: true };

      writeJsonFile(jsonPath, data);

      expect(fs.existsSync(jsonPath)).toBe(true);
    });

    it('should format JSON with 2-space indentation', () => {
      const jsonPath = path.join(tempDir, 'test.json');
      const data = { nested: { value: 'test' } };

      writeJsonFile(jsonPath, data);

      const content = fs.readFileSync(jsonPath, 'utf-8');
      expect(content).toContain('  "nested"');
      expect(content).toContain('    "value"');
    });
  });

  describe('fileExists', () => {
    it('should return true for existing file', () => {
      const filePath = path.join(tempDir, 'test.txt');
      fs.writeFileSync(filePath, 'test');
      expect(fileExists(filePath)).toBe(true);
    });

    it('should return false for non-existent file', () => {
      expect(fileExists(path.join(tempDir, 'nonexistent.txt'))).toBe(false);
    });

    it('should return true for existing directory', () => {
      expect(fileExists(tempDir)).toBe(true);
    });
  });

  describe('isDirectory', () => {
    it('should return true for directory', () => {
      expect(isDirectory(tempDir)).toBe(true);
    });

    it('should return false for file', () => {
      const filePath = path.join(tempDir, 'test.txt');
      fs.writeFileSync(filePath, 'test');
      expect(isDirectory(filePath)).toBe(false);
    });

    it('should return false for non-existent path', () => {
      expect(isDirectory(path.join(tempDir, 'nonexistent'))).toBe(false);
    });
  });

  describe('isFile', () => {
    it('should return true for file', () => {
      const filePath = path.join(tempDir, 'test.txt');
      fs.writeFileSync(filePath, 'test');
      expect(isFile(filePath)).toBe(true);
    });

    it('should return false for directory', () => {
      expect(isFile(tempDir)).toBe(false);
    });

    it('should return false for non-existent path', () => {
      expect(isFile(path.join(tempDir, 'nonexistent.txt'))).toBe(false);
    });
  });

  describe('isWritable', () => {
    it('should return true for writable directory', () => {
      expect(isWritable(tempDir)).toBe(true);
    });

    it('should return true for writable file', () => {
      const filePath = path.join(tempDir, 'test.txt');
      fs.writeFileSync(filePath, 'test');
      expect(isWritable(filePath)).toBe(true);
    });

    it('should return false for non-existent path', () => {
      expect(isWritable(path.join(tempDir, 'nonexistent'))).toBe(false);
    });
  });

  describe('getBasename', () => {
    it('should return basename without extension', () => {
      expect(getBasename('/path/to/file.ini', '.ini')).toBe('file');
      expect(getBasename('file.ini', '.ini')).toBe('file');
    });

    it('should return basename with extension if not specified', () => {
      expect(getBasename('/path/to/file.ini')).toBe('file.ini');
      expect(getBasename('file.ini')).toBe('file.ini');
    });

    it('should return basename if extension does not match', () => {
      expect(getBasename('/path/to/file.ini', '.json')).toBe('file.ini');
    });
  });

  describe('getDirname', () => {
    it('should return directory name', () => {
      expect(getDirname('/path/to/file.ini')).toBe('/path/to');
      expect(getDirname('file.ini')).toBe('.');
    });
  });

  describe('joinPath', () => {
    it('should join path segments', () => {
      expect(joinPath('a', 'b', 'c')).toBe(path.join('a', 'b', 'c'));
      expect(joinPath('/path', 'to', 'file.ini')).toBe(path.join('/path', 'to', 'file.ini'));
    });
  });

  describe('isConfigBundle', () => {
    it('should return true for config bundle', () => {
      const bundlePath = path.join(tempDir, 'bundle.ini');
      const content = `[print:My Profile]
layer_height = 0.2
[filament:PLA]
temperature = 210
`;
      fs.writeFileSync(bundlePath, content);

      expect(isConfigBundle(bundlePath)).toBe(true);
    });

    it('should return false for regular INI file', () => {
      const iniPath = path.join(tempDir, 'regular.ini');
      const content = `layer_height = 0.2
extrusion_width = 0.4
`;
      fs.writeFileSync(iniPath, content);

      expect(isConfigBundle(iniPath)).toBe(false);
    });
  });

  describe('processConfigBundle', () => {
    it('should split config bundle into individual files', () => {
      const bundlePath = path.join(tempDir, 'bundle.ini');
      const content = `# generated by PrusaSlicer

[print:My Print Profile]
layer_height = 0.2
extrusion_width = 0.4

[filament:PLA]
temperature = 210
`;
      fs.writeFileSync(bundlePath, content);

      const { files, headerLine } = processConfigBundle(bundlePath, tempDir);

      expect(files.length).toBe(2);
      expect(headerLine).toBe('# generated by PrusaSlicer');
      expect(files.some(f => f.includes('My Print Profile'))).toBe(true);
      expect(files.some(f => f.includes('PLA'))).toBe(true);
    });

    it('should extract physical printer profiles separately', () => {
      const bundlePath = path.join(tempDir, 'bundle.ini');
      const content = `[printer:My Printer]
nozzle_diameter = 0.4

[physical_printer:My Physical Printer]
host_type = octoprint
`;
      fs.writeFileSync(bundlePath, content);

      const { files } = processConfigBundle(bundlePath, tempDir);

      expect(files.length).toBe(1);
      expect(files[0]).toContain('My Printer');
      expect(fs.existsSync(path.join(tempDir, 'physical_printer', 'My Physical Printer.ini'))).toBe(true);
    });

    it('should handle duplicate profile names', () => {
      const bundlePath = path.join(tempDir, 'bundle.ini');
      const content = `[print:Profile]
layer_height = 0.2

[filament:Profile]
temperature = 210
`;
      fs.writeFileSync(bundlePath, content);

      const { files } = processConfigBundle(bundlePath, tempDir);

      expect(files.length).toBe(2);
      // The first profile keeps the original name, the second gets prefixed
      // Since print comes first, filament will be renamed
      expect(files.some(f => f.includes('filament_Profile'))).toBe(true);
      expect(files.some(f => f.includes('Profile') && !f.includes('filament_'))).toBe(true);
    });

    it('should sanitize filenames based on OS', () => {
      const bundlePath = path.join(tempDir, 'bundle.ini');
      const content = `[print:Test:Profile]
layer_height = 0.2
`;
      fs.writeFileSync(bundlePath, content);

      const { files } = processConfigBundle(bundlePath, tempDir);

      expect(files.length).toBe(1);
      // On macOS/Linux, colon should be removed
      if (process.platform === 'darwin' || process.platform === 'linux') {
        expect(files[0]).not.toContain(':');
      }
    });
  });

  describe('getChildren', () => {
    it('should return all children in directory', () => {
      fs.writeFileSync(path.join(tempDir, 'file1.txt'), 'test1');
      fs.writeFileSync(path.join(tempDir, 'file2.txt'), 'test2');
      fs.mkdirSync(path.join(tempDir, 'subdir'));

      const children = getChildren(tempDir);
      expect(children.length).toBe(3);
    });

    it('should filter by pattern', () => {
      fs.writeFileSync(path.join(tempDir, 'file1.ini'), 'test1');
      fs.writeFileSync(path.join(tempDir, 'file2.json'), 'test2');
      fs.writeFileSync(path.join(tempDir, 'file3.ini'), 'test3');

      const children = getChildren(tempDir, /\.ini$/);
      expect(children.length).toBe(2);
      expect(children.every(c => c.endsWith('.ini'))).toBe(true);
    });

    it('should return empty array for non-existent directory', () => {
      expect(getChildren(path.join(tempDir, 'nonexistent'))).toEqual([]);
    });

    it('should return empty array for file path', () => {
      const filePath = path.join(tempDir, 'test.txt');
      fs.writeFileSync(filePath, 'test');
      expect(getChildren(filePath)).toEqual([]);
    });
  });
});

