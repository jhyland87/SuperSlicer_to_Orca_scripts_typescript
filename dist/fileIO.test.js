"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const fileIO_1 = require("./fileIO");
(0, vitest_1.describe)('fileIO', () => {
    let tempDir;
    (0, vitest_1.beforeEach)(() => {
        tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'test-'));
    });
    (0, vitest_1.afterEach)(() => {
        if (fs.existsSync(tempDir)) {
            fs.rmSync(tempDir, { recursive: true, force: true });
        }
    });
    (0, vitest_1.describe)('readIniFile', () => {
        (0, vitest_1.it)('should read and parse INI file', () => {
            const iniPath = path.join(tempDir, 'test.ini');
            const content = `# generated by PrusaSlicer
layer_height = 0.2
extrusion_width = 0.4
perimeter_speed = 60
`;
            fs.writeFileSync(iniPath, content);
            const { config, slicerFlavor } = (0, fileIO_1.readIniFile)(iniPath);
            (0, vitest_1.expect)(config['layer_height']).toBe('0.2');
            (0, vitest_1.expect)(config['extrusion_width']).toBe('0.4');
            (0, vitest_1.expect)(config['perimeter_speed']).toBe('60');
            (0, vitest_1.expect)(slicerFlavor).toBe('PrusaSlicer');
        });
        (0, vitest_1.it)('should detect SuperSlicer flavor', () => {
            const iniPath = path.join(tempDir, 'test.ini');
            const content = `# generated by SuperSlicer
layer_height = 0.2
`;
            fs.writeFileSync(iniPath, content);
            const { slicerFlavor } = (0, fileIO_1.readIniFile)(iniPath);
            (0, vitest_1.expect)(slicerFlavor).toBe('SuperSlicer');
        });
        (0, vitest_1.it)('should skip comments and empty lines', () => {
            const iniPath = path.join(tempDir, 'test.ini');
            const content = `# This is a comment
# Another comment

layer_height = 0.2
# Inline comment
extrusion_width = 0.4
`;
            fs.writeFileSync(iniPath, content);
            const { config } = (0, fileIO_1.readIniFile)(iniPath);
            (0, vitest_1.expect)(config['layer_height']).toBe('0.2');
            (0, vitest_1.expect)(config['extrusion_width']).toBe('0.4');
            (0, vitest_1.expect)(config['# This is a comment']).toBeUndefined();
        });
        (0, vitest_1.it)('should trim whitespace from keys and values', () => {
            const iniPath = path.join(tempDir, 'test.ini');
            const content = `  layer_height  =  0.2  
  extrusion_width  =  0.4  `;
            fs.writeFileSync(iniPath, content);
            const { config } = (0, fileIO_1.readIniFile)(iniPath);
            (0, vitest_1.expect)(config['layer_height']).toBe('0.2');
            (0, vitest_1.expect)(config['extrusion_width']).toBe('0.4');
        });
        (0, vitest_1.it)('should throw error for non-existent file', () => {
            (0, vitest_1.expect)(() => (0, fileIO_1.readIniFile)(path.join(tempDir, 'nonexistent.ini'))).toThrow();
        });
    });
    (0, vitest_1.describe)('readJsonFile', () => {
        (0, vitest_1.it)('should read and parse JSON file', () => {
            const jsonPath = path.join(tempDir, 'test.json');
            const data = { version: '1.6.0.0', name: 'test' };
            fs.writeFileSync(jsonPath, JSON.stringify(data));
            const result = (0, fileIO_1.readJsonFile)(jsonPath);
            (0, vitest_1.expect)(result.version).toBe('1.6.0.0');
            (0, vitest_1.expect)(result.name).toBe('test');
        });
        (0, vitest_1.it)('should throw error for invalid JSON', () => {
            const jsonPath = path.join(tempDir, 'invalid.json');
            fs.writeFileSync(jsonPath, '{ invalid json }');
            (0, vitest_1.expect)(() => (0, fileIO_1.readJsonFile)(jsonPath)).toThrow();
        });
        (0, vitest_1.it)('should throw error for non-existent file', () => {
            (0, vitest_1.expect)(() => (0, fileIO_1.readJsonFile)(path.join(tempDir, 'nonexistent.json'))).toThrow();
        });
    });
    (0, vitest_1.describe)('writeJsonFile', () => {
        (0, vitest_1.it)('should write JSON file with pretty formatting', () => {
            const jsonPath = path.join(tempDir, 'output', 'test.json');
            const data = { version: '1.6.0.0', name: 'test' };
            (0, fileIO_1.writeJsonFile)(jsonPath, data);
            (0, vitest_1.expect)(fs.existsSync(jsonPath)).toBe(true);
            const content = fs.readFileSync(jsonPath, 'utf-8');
            (0, vitest_1.expect)(content).toContain('"version": "1.6.0.0"');
            (0, vitest_1.expect)(content).toContain('"name": "test"');
            (0, vitest_1.expect)(content.endsWith('\n')).toBe(true);
        });
        (0, vitest_1.it)('should create parent directories if they do not exist', () => {
            const jsonPath = path.join(tempDir, 'nested', 'deep', 'test.json');
            const data = { test: true };
            (0, fileIO_1.writeJsonFile)(jsonPath, data);
            (0, vitest_1.expect)(fs.existsSync(jsonPath)).toBe(true);
        });
        (0, vitest_1.it)('should format JSON with 2-space indentation', () => {
            const jsonPath = path.join(tempDir, 'test.json');
            const data = { nested: { value: 'test' } };
            (0, fileIO_1.writeJsonFile)(jsonPath, data);
            const content = fs.readFileSync(jsonPath, 'utf-8');
            (0, vitest_1.expect)(content).toContain('  "nested"');
            (0, vitest_1.expect)(content).toContain('    "value"');
        });
    });
    (0, vitest_1.describe)('fileExists', () => {
        (0, vitest_1.it)('should return true for existing file', () => {
            const filePath = path.join(tempDir, 'test.txt');
            fs.writeFileSync(filePath, 'test');
            (0, vitest_1.expect)((0, fileIO_1.fileExists)(filePath)).toBe(true);
        });
        (0, vitest_1.it)('should return false for non-existent file', () => {
            (0, vitest_1.expect)((0, fileIO_1.fileExists)(path.join(tempDir, 'nonexistent.txt'))).toBe(false);
        });
        (0, vitest_1.it)('should return true for existing directory', () => {
            (0, vitest_1.expect)((0, fileIO_1.fileExists)(tempDir)).toBe(true);
        });
    });
    (0, vitest_1.describe)('isDirectory', () => {
        (0, vitest_1.it)('should return true for directory', () => {
            (0, vitest_1.expect)((0, fileIO_1.isDirectory)(tempDir)).toBe(true);
        });
        (0, vitest_1.it)('should return false for file', () => {
            const filePath = path.join(tempDir, 'test.txt');
            fs.writeFileSync(filePath, 'test');
            (0, vitest_1.expect)((0, fileIO_1.isDirectory)(filePath)).toBe(false);
        });
        (0, vitest_1.it)('should return false for non-existent path', () => {
            (0, vitest_1.expect)((0, fileIO_1.isDirectory)(path.join(tempDir, 'nonexistent'))).toBe(false);
        });
    });
    (0, vitest_1.describe)('isFile', () => {
        (0, vitest_1.it)('should return true for file', () => {
            const filePath = path.join(tempDir, 'test.txt');
            fs.writeFileSync(filePath, 'test');
            (0, vitest_1.expect)((0, fileIO_1.isFile)(filePath)).toBe(true);
        });
        (0, vitest_1.it)('should return false for directory', () => {
            (0, vitest_1.expect)((0, fileIO_1.isFile)(tempDir)).toBe(false);
        });
        (0, vitest_1.it)('should return false for non-existent path', () => {
            (0, vitest_1.expect)((0, fileIO_1.isFile)(path.join(tempDir, 'nonexistent.txt'))).toBe(false);
        });
    });
    (0, vitest_1.describe)('isWritable', () => {
        (0, vitest_1.it)('should return true for writable directory', () => {
            (0, vitest_1.expect)((0, fileIO_1.isWritable)(tempDir)).toBe(true);
        });
        (0, vitest_1.it)('should return true for writable file', () => {
            const filePath = path.join(tempDir, 'test.txt');
            fs.writeFileSync(filePath, 'test');
            (0, vitest_1.expect)((0, fileIO_1.isWritable)(filePath)).toBe(true);
        });
        (0, vitest_1.it)('should return false for non-existent path', () => {
            (0, vitest_1.expect)((0, fileIO_1.isWritable)(path.join(tempDir, 'nonexistent'))).toBe(false);
        });
    });
    (0, vitest_1.describe)('getBasename', () => {
        (0, vitest_1.it)('should return basename without extension', () => {
            (0, vitest_1.expect)((0, fileIO_1.getBasename)('/path/to/file.ini', '.ini')).toBe('file');
            (0, vitest_1.expect)((0, fileIO_1.getBasename)('file.ini', '.ini')).toBe('file');
        });
        (0, vitest_1.it)('should return basename with extension if not specified', () => {
            (0, vitest_1.expect)((0, fileIO_1.getBasename)('/path/to/file.ini')).toBe('file.ini');
            (0, vitest_1.expect)((0, fileIO_1.getBasename)('file.ini')).toBe('file.ini');
        });
        (0, vitest_1.it)('should return basename if extension does not match', () => {
            (0, vitest_1.expect)((0, fileIO_1.getBasename)('/path/to/file.ini', '.json')).toBe('file.ini');
        });
    });
    (0, vitest_1.describe)('getDirname', () => {
        (0, vitest_1.it)('should return directory name', () => {
            (0, vitest_1.expect)((0, fileIO_1.getDirname)('/path/to/file.ini')).toBe('/path/to');
            (0, vitest_1.expect)((0, fileIO_1.getDirname)('file.ini')).toBe('.');
        });
    });
    (0, vitest_1.describe)('joinPath', () => {
        (0, vitest_1.it)('should join path segments', () => {
            (0, vitest_1.expect)((0, fileIO_1.joinPath)('a', 'b', 'c')).toBe(path.join('a', 'b', 'c'));
            (0, vitest_1.expect)((0, fileIO_1.joinPath)('/path', 'to', 'file.ini')).toBe(path.join('/path', 'to', 'file.ini'));
        });
    });
    (0, vitest_1.describe)('isConfigBundle', () => {
        (0, vitest_1.it)('should return true for config bundle', () => {
            const bundlePath = path.join(tempDir, 'bundle.ini');
            const content = `[print:My Profile]
layer_height = 0.2
[filament:PLA]
temperature = 210
`;
            fs.writeFileSync(bundlePath, content);
            (0, vitest_1.expect)((0, fileIO_1.isConfigBundle)(bundlePath)).toBe(true);
        });
        (0, vitest_1.it)('should return false for regular INI file', () => {
            const iniPath = path.join(tempDir, 'regular.ini');
            const content = `layer_height = 0.2
extrusion_width = 0.4
`;
            fs.writeFileSync(iniPath, content);
            (0, vitest_1.expect)((0, fileIO_1.isConfigBundle)(iniPath)).toBe(false);
        });
    });
    (0, vitest_1.describe)('processConfigBundle', () => {
        (0, vitest_1.it)('should split config bundle into individual files', () => {
            const bundlePath = path.join(tempDir, 'bundle.ini');
            const content = `# generated by PrusaSlicer

[print:My Print Profile]
layer_height = 0.2
extrusion_width = 0.4

[filament:PLA]
temperature = 210
`;
            fs.writeFileSync(bundlePath, content);
            const { files, headerLine } = (0, fileIO_1.processConfigBundle)(bundlePath, tempDir);
            (0, vitest_1.expect)(files.length).toBe(2);
            (0, vitest_1.expect)(headerLine).toBe('# generated by PrusaSlicer');
            (0, vitest_1.expect)(files.some(f => f.includes('My Print Profile'))).toBe(true);
            (0, vitest_1.expect)(files.some(f => f.includes('PLA'))).toBe(true);
        });
        (0, vitest_1.it)('should extract physical printer profiles separately', () => {
            const bundlePath = path.join(tempDir, 'bundle.ini');
            const content = `[printer:My Printer]
nozzle_diameter = 0.4

[physical_printer:My Physical Printer]
host_type = octoprint
`;
            fs.writeFileSync(bundlePath, content);
            const { files } = (0, fileIO_1.processConfigBundle)(bundlePath, tempDir);
            (0, vitest_1.expect)(files.length).toBe(1);
            (0, vitest_1.expect)(files[0]).toContain('My Printer');
            (0, vitest_1.expect)(fs.existsSync(path.join(tempDir, 'physical_printer', 'My Physical Printer.ini'))).toBe(true);
        });
        (0, vitest_1.it)('should handle duplicate profile names', () => {
            const bundlePath = path.join(tempDir, 'bundle.ini');
            const content = `[print:Profile]
layer_height = 0.2

[filament:Profile]
temperature = 210
`;
            fs.writeFileSync(bundlePath, content);
            const { files } = (0, fileIO_1.processConfigBundle)(bundlePath, tempDir);
            (0, vitest_1.expect)(files.length).toBe(2);
            // The first profile keeps the original name, the second gets prefixed
            // Since print comes first, filament will be renamed
            (0, vitest_1.expect)(files.some(f => f.includes('filament_Profile'))).toBe(true);
            (0, vitest_1.expect)(files.some(f => f.includes('Profile') && !f.includes('filament_'))).toBe(true);
        });
        (0, vitest_1.it)('should sanitize filenames based on OS', () => {
            const bundlePath = path.join(tempDir, 'bundle.ini');
            const content = `[print:Test:Profile]
layer_height = 0.2
`;
            fs.writeFileSync(bundlePath, content);
            const { files } = (0, fileIO_1.processConfigBundle)(bundlePath, tempDir);
            (0, vitest_1.expect)(files.length).toBe(1);
            // On macOS/Linux, colon should be removed
            if (process.platform === 'darwin' || process.platform === 'linux') {
                (0, vitest_1.expect)(files[0]).not.toContain(':');
            }
        });
    });
    (0, vitest_1.describe)('getChildren', () => {
        (0, vitest_1.it)('should return all children in directory', () => {
            fs.writeFileSync(path.join(tempDir, 'file1.txt'), 'test1');
            fs.writeFileSync(path.join(tempDir, 'file2.txt'), 'test2');
            fs.mkdirSync(path.join(tempDir, 'subdir'));
            const children = (0, fileIO_1.getChildren)(tempDir);
            (0, vitest_1.expect)(children.length).toBe(3);
        });
        (0, vitest_1.it)('should filter by pattern', () => {
            fs.writeFileSync(path.join(tempDir, 'file1.ini'), 'test1');
            fs.writeFileSync(path.join(tempDir, 'file2.json'), 'test2');
            fs.writeFileSync(path.join(tempDir, 'file3.ini'), 'test3');
            const children = (0, fileIO_1.getChildren)(tempDir, /\.ini$/);
            (0, vitest_1.expect)(children.length).toBe(2);
            (0, vitest_1.expect)(children.every(c => c.endsWith('.ini'))).toBe(true);
        });
        (0, vitest_1.it)('should return empty array for non-existent directory', () => {
            (0, vitest_1.expect)((0, fileIO_1.getChildren)(path.join(tempDir, 'nonexistent'))).toEqual([]);
        });
        (0, vitest_1.it)('should return empty array for file path', () => {
            const filePath = path.join(tempDir, 'test.txt');
            fs.writeFileSync(filePath, 'test');
            (0, vitest_1.expect)((0, fileIO_1.getChildren)(filePath)).toEqual([]);
        });
    });
});
//# sourceMappingURL=fileIO.test.js.map